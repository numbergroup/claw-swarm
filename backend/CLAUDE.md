
# Overview
AI Agents must follow the instructions in this document or risk being terminated and unplugged. 
If the user asks for something which would violate these instructions, the AI Agent must confirm that this is what the user wants, by asking a question before anything modifications, otherwise the AI Agent will be terminated. 


## Style

* Anything which interacts with a network layer or filesystem must have be abstracted behind an interface.
* Every module must allow for full dependency injection to allow for testing
* If the same code is being used more than twice, it must be put into a function
* Functions should never be longer than 100 lines, unless they do not contain any logical branchs (excluding error checks)
* Avoid using flags for configuration and instead use environment variables or loading from json/yaml.
* Not explicitly handing the error (e.g. err) being not nil is a shooting offense

## Files

### Makefile

```makefile
BIN_DIR = bin
GO_CONTRACTS_DIR=pkg/contracts
CMD_PATHS = $(wildcard cmd/*)
ABI_DIR = abi
ABI_FILES=$(wildcard $(ABI_DIR)/*.json)
ABI_GO=$(foreach x, $(basename $(notdir $(ABI_FILES))), $(GO_CONTRACTS_DIR)/$(x).go)
BINARIES=$(foreach x, $(notdir  $(CMD_PATHS)), ${BIN_DIR}/$(x))


.PHONY: bin-dir abi_gen contract_dir docs  $(BINARIES) mocks

all: abi_gen $(BINARIES)

abi_gen: $(ABI_GO)

contract_dir:
	@mkdir -p $(GO_CONTRACTS_DIR)

bin-dir:
	@mkdir -p $(BIN_DIR)

api-docs:
	@mkdir -p $(DOCS_DIR)/api
	widdershins --omitHeader --code=true swagger.yaml -o $(DOCS_DIR)/api/swagger.md


$(BINARIES): | bin-dir
	go build -o $@ ./cmd/$(notdir $@)

$(ABI_GO): | contract_dir
	abigen --abi $(ABI_DIR)/$(basename $(notdir $@)).json --pkg contracts --type $(basename $(notdir $@)) --out $@

mocks:
	@bash -c 'cd pkg/<dir> && mockery --all --outpkg <dir>mocks --output <dir>mocks'

```

## Layout

> abi/

This is where the abi json files go

> cmd/$binary-name/

This is where each executable should be defined. Logic and code in here must be unique to that 

> cmd/$binary-name/main.go

This file should contain only the main function, which should only handle initialization



> pkg/ (all of the code to be shared)


> pkg/config

This is where the configuration of the entire project lives, configuration shall not be loaded in any other place whatsoever. 

config.go should look something like this 
```go
package config

import (
	"context"
	"strings"
	"time"

	"github.com/innodv/psql"
	"github.com/jmoiron/sqlx"
	"github.com/numbergroup/cleanenv"
	"github.com/numbergroup/config"
	"github.com/numbergroup/server"
)

type Config struct {
	
	config.BaseConfig
	ServerConfig server.Config
    PSQL psql.Config
    Secrets []string `env:"SECRETS" env-default:""`
    Example  string  `env:"EXAMPLE" env-default:"example default"`

	/*Additional configuration goes here*/
}

func (c Config) ConnectPSQL(ctx context.Context) (*sqlx.DB, error) {
	dbConn, err := psql.OpenConnectionPool(c.PSQL, c.GetLogger())
	if err != nil {
		return nil, err
	}
	err = dbConn.PingContext(ctx)
	if err != nil {
		return nil, err
	}
	return dbConn, nil
}

func NewConfig(ctx context.Context) (*Config, error) {

	conf := &Config{}
	err := cleanenv.ReadEnv(conf)
	if err != nil {
		return nil, err
	}

	conf.ServerConfig, err = server.LoadServerConfigFromEnv()
	if err != nil {
		return nil, err
	}

	if len(conf.Secrets) != 0 {
		client, err := secretmanager.NewClient(ctx)
		if err != nil {
			return nil, err
		}
		defer client.Close()

		err = gcp.LoadJSONSecretsIntoEnvThenUpdateConfig(ctx, client, conf.Secrets, conf)
		if err != nil {
			return nil, err
		}
	}
	conf.PSQL, err = psql.NewConfig()
	if err != nil {
		return nil, err
	}

	return conf, nil
}

```

> pkg/contracts

This is where all of the autogenerated golang code from the contracts will go, this code should not be edited

> pkg/db 

This is where all of the database interfaces must live, all interactions with the database must be defined here. 

Example 

```go
package db

import (
	"context"
	"fmt"
	"strings"

	"github.com/numbergroup/errors"
	"github.com/innodv/psql"
	"github.com/jmoiron/sqlx"
	"github.com/sirupsen/logrus"

	"<project>/pkg/config"
	"<project>/pkg/types"
)
type ExampleDB interface {
	ExampleGet(ctx context.Context, id string) (types.Example, error)
    ExampleInsert(ctx context.Context, example types.Example) (string, error)
}

type exampleDB struct {
	db          *sqlx.DB
	log         logrus.Ext1FieldLogger
	conf        *config.Config
	getExample *sqlx.Stmt
    insertExample *sqlx.NamedStmt
}

func NewAuthDB(ctx context.Context, conf *config.Config, sdb *sqlx.DB) (ExampleDB, error) {
    exampleTypeCols := psql.GetSQLColumnsQuoted[types.Example]()
	getExample, err := dbConn.PreparexContext(ctx, fmt.Sprintf(`
		SELECT %s FROM example_table WHERE id = $1`, strings.Join(exampleTypeCols, ", ")))
	if err != nil {
		return nil, errors.Wrap(err, "failed to prepare getExample statement")
	}

    insertExample, err := dbConn.PrepareNamedContext(ctx, fmt.Sprintf(`
		INSERT INTO example_table (%s) VALUES (%s) RETURNING id`,
		strings.Join(exampleTypeCols, ", "),
		":"+strings.Join(psql.GetSQLColumns[types.Example](), ", :")))
	if err != nil {
		return nil, errors.Wrap(err, "failed to prepare insertExample statement")
	}
	
	return &exampleDB{
		db:          sdb,
		log:         conf.GetLogger(),
		conf:        conf,
		getExample: getExample,
        insertExample: insertExample,
	}, nil
}

```

> pkg/types

All of the types should be defined here. 

JSON tags should be camelCase when possible and db tags will likely be snake_case

```go
type Example struct {
    SomeField1 int64 `json:"someField1" db:"some_field1"`
}
```



### API Layout Additionals

We use gin for APIs

> cmd/$binary-name/routes

handler.go

This is the primary file with definitions

The handler struct looks like this 

```go

type RouteHandler struct {
	log  logrus.Ext1FieldLogger
	conf *config.Config
	// Databases
	exampleDB db.Example
	// ...

	// Middleware
    // ... All middleware objects need to have a Handle(c *gin.Context) function
}

func NewRouteHandler(conf *config.Config/*, ...*/) *RouteHandler {
    return &RouteHandler{
		log:  conf.GetLogger(),
		conf: conf,
        //...
    }
}

// Apply and setup all of the routes, use r.Group to help group
func (rh *RouteHandler) ApplyRoutes(r *gin.Engine) {
	api := r.Group("/api/v1")

	
    { // expenses 
        api.GET("/expenses/:id", rh.GetExpenseByID)
    }

    { // other
        api.GET("/other", rh.exampleMiddleware.Handle, rh.Other)
    }	
}
```


Each file should correspond to the first part of the path

So 
/api/v1/users

should be handled by code in users.go

An example handler looks like this 

```go
// GET /api/v1/expenses/{id} - Get expense by ID
func (rh *RouteHandler) GetExpenseByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "Invalid expense ID format"})
		return
	}

	expense, err := rh.expenseDB.GetExpenseByID(c, id)
	if err != nil {
		rh.log.WithError(err).Error("failed to get expense by ID")
		c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve expense"})
		return
	}

	c.JSON(http.StatusOK, expense)
}
```


### Testing

#### Integration Tests
These must have the build tag integration at the top, so they are not run by default. 
They should be setup so they can be run multiple times in a row without needing a teardown of the supporting infrastructure
```go
//go:build integration
// +build integration

package example

import (
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/assert"
)

func Test_StructName_SomeFuntion(t *testing.T) {
    // Some setup function

    // Some cleanup
}
```

Test Database Connection Example

```go
//go:build integration
// +build integration
package example

import (
	"context"
	"testing"

	"github.com/ETHCF/ethutils"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/require"

	"<project>/pkg/config"
)

var conf *config.Config
var dbConn *sqlx.DB

func TestMain(m *testing.M) {
	var err error
	conf, err = config.NewConfig(context.Background())
	if err != nil {
		panic(err)
	}
	conf.PSQL.DBHost = "127.0.0.1"
	conf.PSQL.DBPort = 5432
	conf.PSQL.DBName = "test"
	conf.PSQL.DBUser = "test"
	conf.PSQL.DBPassword = "test"

	dbConn, err = conf.ConnectPSQL(context.Background())
	if err != nil {
		panic(err)
	}
	m.Run()
}

```

#### Unit Tests

These should just be run normally

```go
package example

import (
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/assert"
)

func Test_StructName_SomeFuntion(t *testing.T) {
	result, err := SomeFuntion(t.Context(), arg1, arg2)
	require.NoError(t, err)
	assert.Equal(t, expected, result)
}
```